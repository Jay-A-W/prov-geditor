<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/jointjs/2.1.0/joint.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="css/editor.css">
</head>
<body>
    <!-- content -->
    <div id="prov-editor">
        <sidebar></sidebar>
        <namespace-modal></namespace-modal>
        <element-modal></element-modal>
        <export-modal></export-modal>
        <div class="menu">
            <ul class="menu-options">
                <li class="menu-option option-wasGeneratedBy" onclick="addRelation('wasGeneratedBy')" hidden>wasGeneratedBy</li>
                <li class="menu-option option-wasDerivedFrom" onclick="addRelation('wasDerivedFrom')" hidden>wasDerivedFrom</li>
                <li class="menu-option option-wasAttributedTo" onclick="addRelation('wasAttributedTo')" hidden>wasAttributedTo</li>
                <li class="menu-option option-used" onclick="addRelation('used')" hidden>used</li>
                <li class="menu-option option-wasInformedBy" onclick="addRelation('wasInformedBy')" hidden>wasInformedBy</li>
                <li class="menu-option option-wasAssociatedWith" onclick="addRelation('wasAssociatedWith')" hidden>wasAssociatedWith</li>
                <li class="menu-option option-actedOnBehalfOf" onclick="addRelation('actedOnBehalfOf')" hidden>actedOnBehalfOf</li>
                
                <li class="menu-option option-wasInfluencedBy" onclick="addRelation('wasInfluencedBy')" hidden>wasInfluencedBy</li>
                <li class="menu-option option-hadPrimarySource" onclick="addRelation('hadPrimarySource')" hidden>hadPrimarySource</li>
                <li class="menu-option option-wasQuotedFrom" onclick="addRelation('wasQuotedFrom')" hidden>wasQuotedFrom</li>
                <li class="menu-option option-wasRevisionOf" onclick="addRelation('wasRevisionOf')" hidden>wasRevisionOf</li>
                <li class="menu-option option-wasInvalidatedBy" onclick="addRelation('wasInvalidatedBy')" hidden>wasInvalidatedBy</li>
                <li class="menu-option option-wasStartedBy" onclick="addRelation('wasStartedBy')" hidden>wasStartedBy</li>
                <li class="menu-option option-wasEndedBy" onclick="addRelation('wasEndedBy')" hidden>wasEndedBy</li>
            </ul>
        </div>
        <div id="graph"></div>
        <a href="#" onclick="show_doc_json(doc.scope);">exampleexample</a>
    </div>
    <!-- dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script src="https://unpkg.com/vuex"></script>
    <script src="https://cdn.jsdelivr.net/npm/es6-promise@4/dist/es6-promise.auto.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.10.1/lodash.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/backbone.js/1.3.3/backbone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jointjs/2.1.0/joint.js"></script>
    <script src="lib/customShapes/joint.shapes.custom.js"></script>
    <script type="text/javascript" src="lib/prov.js"></script>
    <script type="text/javascript" src="lib/api.js"></script>
    <script src="js/provFunc.js"></script>
    <script src="js/utlityFunctions.js"></script>
    <!-- Vue Declaration -->
    <script src="vue/sidebar.js"></script>
    <script src="vue/nameSpaceModal.js"></script>
    <script src="vue/elementModal.js"></script>
    <script src="vue/exportModal.js"></script>
    <script src="vue/index.js"></script>
    

    <!-- code -->
    <script type="text/javascript">
        //CURRENTLY LINKING WITH REVISION, QUOTATION, PRIMARYSOURCE DOES NOT WORK AS API IS MISSING FUNC!!!

        let doc = prov.document();
        store.commit("addPrefixToSet", 'xsd');
        store.commit("addPrefixToSet", 'prov');
        var def = doc.setDefaultNamespace("http://default.example.com/");
        store.commit("addPrefixToSet", 'def');
        var ex = doc.addNamespace("ex", "http://www.example.org/");
        store.commit("addPrefixToSet", 'ex');

        let json = {};
        let graph = new joint.dia.Graph;

        //localStorage.clear();
        var paper = new joint.dia.Paper({
            el: document.getElementById('graph'),
            model: graph,
            width: 2000,
            height: 2000,
            gridSize: 1,
            linkPinning: false,
            defaultLink: new joint.shapes.custom.fsa.Arrow({
            }),
            elementView: joint.dia.ElementView.extend({
                pointerdblclick: function (evt, x, y) {
                    showModal();
                    store.commit("setCurrentElement", this);
                    //let input = prompt("Enter element name");
                    //let type = this.model.attributes.type.replace("custom.", "");
                    //let currentName = this.model.attributes.attrs.label.text;
                    //editPROVElement(type, currentName, input);
                    //this.model.attr('label/text', input);
                    //this.model.remove();
                }
            }),
            linkView: joint.dia.LinkView.extend({
     
            }),
        });

        if (localStorage.getItem('graph')) { //HAS TO BE DONE AFTER INSTANTIATION OF PAPER AS PAPER IS WHAT REACTS TO UPDATE GRAPH VISUALLY
            graph.fromJSON(JSON.parse(localStorage.getItem('graph')));
        }
       
        //if (localStorage.getItem('doc')) {  //LOCAL STORAGE OF DOC needs to be done
        //    console.log(localStorage.getItem('doc'));
        //    doc = localStorage.getItem('doc');
        //}

        const menu = document.querySelector(".menu");
        let menuVisible = false;

        const toggleMenu = command => {
            menu.style.display = command === "show" ? "block" : "none";
            menuVisible = !menuVisible;
        };

        const setPosition = ({ top, left }) => {
            menu.style.left = `${left}px`;
            menu.style.top = `${top}px`;
            toggleMenu('show');
        };

        function showModal(){
            $("#elementModal").show();
        };

        function addRelation(label){
            store.commit("setCurrentLinkLabel", label);
            doc[label]("ex:" + store.state.currentSource.attributes.attrs.label.text, "ex:" + store.state.currentTarget.attributes.attrs.label.text);
            localStorage.setItem('graph', JSON.stringify(graph));
            for (let child of $(".menu-options").children()){
                child.style.display = "none";
            }
            toggleMenu('hide');
        };

        function hideContextOptions(source, target){
            let menuOptions = document.querySelector(".menu-options");
   
            let sourceType = source.attributes.type;
            let targetType = target.attributes.type;

            //let entity2Entity = ['wasDerivedFrom', 'wasInfluencedBy', 'hadPrimarySource', 'wasQuotedFrom', 'wasRevisionOf']; wasPrimary, Quoted and Revision has not been incorporate into the PROV api yet
            let entity2Entity = ['wasDerivedFrom', 'wasInfluencedBy'];
            let entity2Activity = ['wasGeneratedBy', 'wasInfluencedBy', 'wasInvalidatedBy'];
            let entity2Agent = ['wasAttributedTo', 'wasInfluencedBy'];
            let activity2Activity = ['wasInformedBy', 'wasInfluencedBy'];
            let activity2Entity = ['used', 'wasInfluencedBy', 'wasStartedBy', 'wasEndedBy'];
            let activity2Agent = ['wasAssociatedWith', 'wasInfluencedBy'];
            let agent2Agent = ['actedOnBehalfOf', 'wasInfluencedBy'];
            let agent2Entity = ['wasInfluencedBy'];
            let agent2Activity = ['wasInfluencedBy'];
            
            let validOptions;
            if (sourceType == 'custom.Entity'){
                switch (targetType){
                    case 'custom.Entity':
                        validOptions = entity2Entity;
                        break;
                    case 'custom.Activity':
                        validOptions = entity2Activity;
                        break;
                    case 'custom.Agent':
                        validOptions = entity2Agent;
                        break;
                }
            } else if (sourceType == 'custom.Activity'){
                switch (targetType){
                    case 'custom.Entity':
                        validOptions = activity2Entity;
                        break;
                    case 'custom.Activity':
                        validOptions = activity2Activity;
                        break;
                    case 'custom.Agent':
                        validOptions = activity2Agent;
                        break;
                }
            } else if (sourceType == 'custom.Agent'){
                switch (targetType){
                    case 'custom.Entity':
                        validOptions = agent2Entity;
                        break;
                    case 'custom.Activity':
                        validOptions = agent2Activity;
                        break;
                    case 'custom.Agent':
                        validOptions = agent2Agent;
                        break;
                }
            }
            for (let option of validOptions){
                $(".option-"+option).show();
            }
        };

        function getElementById(id){
            for (let element of graph.getElements()){
                if (element.id === id){
                    return element;
                }
            }
        };

        //On connection
        graph.on('change:source change:target', function (link) {
            let source = link.get('source');
            let target = link.get('target');
            if (source.id && target.id) {
                // both ends of the link are connected.
                const origin = {
                    left: event.clientX,
                    top: event.clientY
                };
                setPosition(origin);
                let sourceElement = getElementById(source.id);
                let targetElement = getElementById(target.id);
                
                hideContextOptions(sourceElement, targetElement);
                store.commit("setCurrentSource", getElementById(source.id));
                store.commit("setCurrentTarget", getElementById(target.id));
                store.commit("setCurrentLink", link);
                //console.log(graph);
                return false;
            }
        })

        function filterOutLink(link, qualifiedInfluence) {
            let source = getElementById(link.attributes.source.id);
            let target = getElementById(link.attributes.target.id);
            let sourceType = source.attributes.type.replace("custom.", "");
            let targetType = target.attributes.type.replace("custom.", "");
            let filtered = doc.scope.statements.filter(function (link) {
                if (link.constructor.name == qualifiedInfluence) {
                    if ((link.properties.hasOwnProperty(sourceType.toLowerCase())) && (link.properties.hasOwnProperty(targetType.toLowerCase()))) {
                        if ((link[sourceType.toLowerCase()].localPart == source.attributes.attrs.label.text) && (link[targetType.toLowerCase()].localPart == target.attributes.attrs.label.text)) {
                            return false;
                        }
                    }
                }
                return true;
            });
            return filtered;
        }
        function deleteRelationInDoc(link){
            let relType = link.attributes.attrs.relType;
            let qualifiedInfluence;
            let filtered;
            let source = getElementById(link.attributes.source.id);
            let target = getElementById(link.attributes.target.id);
            let sourceType = source.attributes.type.replace("custom.", "");
            let targetType = target.attributes.type.replace("custom.", "");
            switch (relType) {
                case "wasGeneratedBy":
                    qualifiedInfluence = "Generation";
                    filtered = filterOutLink(link, qualifiedInfluence);
                    doc.scope.statements = filtered;
                    break;
                case "wasDerivedFrom":
                    qualifiedInfluence = "Derivation";
                    filtered = doc.scope.statements.filter(function (link) {
                        if (link.constructor.name == qualifiedInfluence) {
                            if ((link.properties.hasOwnProperty('generatedEntity') && (link.properties.hasOwnProperty('usedEntity')))) {
                                if ((link['generatedEntity'].localPart == source.attributes.attrs.label.text) && (link['usedEntity'].localPart == target.attributes.attrs.label.text)) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    });
                    doc.scope.statements = filtered;
                    break;
                case "wasAttributedTo":
                    qualifiedInfluence = "Attribution";
                    filtered = filterOutLink(link, qualifiedInfluence);
                    doc.scope.statements = filtered;
                    break;
                case "used":
                    qualifiedInfluence = "Usage";
                    filtered = filterOutLink(link, qualifiedInfluence);
                    doc.scope.statements = filtered;
                    break;
                case "wasInformedBy":
                    qualifiedInfluence = "Communication";
                    filtered = doc.scope.statements.filter(function (link) {
                        if (link.constructor.name == qualifiedInfluence) {
                            if ((link.properties.hasOwnProperty('informed') && (link.properties.hasOwnProperty('informant')))) {
                                if ((link['informed'].localPart == source.attributes.attrs.label.text) && (link['informant'].localPart == target.attributes.attrs.label.text)) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    });
                    doc.scope.statements = filtered;
                    break;
                case "wasAssociatedWith":
                    qualifiedInfluence = "Association";
                    filtered = filterOutLink(link, qualifiedInfluence);
                    doc.scope.statements = filtered;
                    break;
                case "actedOnBehalfOf":
                    qualifiedInfluence = "Delegation";
                    filtered = doc.scope.statements.filter(function (link) {
                        if (link.constructor.name == qualifiedInfluence) {
                            if ((link.properties.hasOwnProperty('delegate') && (link.properties.hasOwnProperty('responsible')))) {
                                if ((link['delegate'].localPart == source.attributes.attrs.label.text) && (link['responsible'].localPart == target.attributes.attrs.label.text)) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    });
                    doc.scope.statements = filtered;
                    break;
                case "wasInfluencedBy":
                    qualifiedInfluence = "Influence";
                    filtered = doc.scope.statements.filter(function (link) {
                        if (link.constructor.name == qualifiedInfluence) {
                            if ((link.properties.hasOwnProperty('influencee') && (link.properties.hasOwnProperty('influencer')))) {
                                if ((link['influencee'].localPart == source.attributes.attrs.label.text) && (link['influencer'].localPart == target.attributes.attrs.label.text)) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    });
                    doc.scope.statements = filtered;
                    break;
                case "hadPrimarySource":
                    qualifiedInfluence = "PrimarySource";
                    filtered = filterOutLink(link, qualifiedInfluence);
                    doc.scope.statements = filtered;
                    break;
                case "wasQuotedFrom":
                    qualifiedInfluence = "Quotation";
                    filtered = filterOutLink(link, qualifiedInfluence);
                    doc.scope.statements = filtered;
                    break;
                case "wasRevisionOf":
                    qualifiedInfluence = "Revision";
                    filtered = filterOutLink(link, qualifiedInfluence);
                    doc.scope.statements = filtered;
                    break;
                case "wasInvalidatedBy":
                    qualifiedInfluence = "Invalidation";
                    filtered = filterOutLink(link, qualifiedInfluence);
                    doc.scope.statements = filtered;
                    break;
                case "wasStartedBy":
                    qualifiedInfluence = "Start";
                    filtered = doc.scope.statements.filter(function (link) {
                        if (link.constructor.name == qualifiedInfluence) {
                            if ((link.properties.hasOwnProperty(sourceType.toLowerCase()) && (link.properties.hasOwnProperty('trigger')))) {
                                if ((link[sourceType.toLowerCase()].localPart == source.attributes.attrs.label.text) && (link['trigger'].localPart == target.attributes.attrs.label.text)) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    });
                    doc.scope.statements = filtered;
                    break;
                case "wasEndedBy":
                    qualifiedInfluence = "End";
                    filtered = doc.scope.statements.filter(function (link) {
                        if (link.constructor.name == qualifiedInfluence) {
                            if ((link.properties.hasOwnProperty(sourceType.toLowerCase()) && (link.properties.hasOwnProperty('trigger')))) {
                                if ((link[sourceType.toLowerCase()].localPart == source.attributes.attrs.label.text) && (link['trigger'].localPart == target.attributes.attrs.label.text)) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    });
                    doc.scope.statements = filtered;
                    break;
            }
            //console.log(link);
            //console.log(doc.scope.statements);
        };

        //graph.on('remove', function(cell, cellView, evt) {
        //    if (cell.isLink()) {
        //    }
        //})

        paper.on('tool:remove', function (link, linkView, evt) {
            deleteRelationInDoc(link.model);
            link.model.remove();
            localStorage.setItem('graph', JSON.stringify(graph));
        })
    
        paper.on('delete:button:pointerdown', function (elementView, evt) {
            evt.stopPropagation(); // stop any further actions with the element view (e.g. dragging)
            let model = elementView.model;
            let type = model.attributes.type.replace("custom.", "");
            let currentName = model.attributes.attrs.label.text;
            //let provElement = doc.scope.statements.filter(elementType => elementType.constructor.name == type).filter(element => element.identifier.localPart == currentName);
            let connectedLinks = graph.getConnectedLinks(model);
            for (let link of connectedLinks) {
                link.remove();
                deleteRelationInDoc(link);
            }
            let filtered = doc.scope.statements.filter(function (element) {
                if ((element.constructor.name == type) && (element.identifier.localPart == currentName)) {
                    return false;
                } else {
                    return true;
                }
            });
            doc.scope.statements = filtered;
            model.remove();
            localStorage.setItem('graph', JSON.stringify(graph));
        });

        function link(source, target, label, vertices) {
            //doc.used("ex:" + source.id, "ex:" + target.id);
            //doc['used']("ex:" + source.id, "ex:" + target.id);
            let labelFunc = doc[label];

            //console.log(typeof labelFunc !== 'function');
            if (typeof labelFunc !== 'function') {
                throw new Error('invalid label type '+label);
            } else {
                var cell = new joint.shapes.fsa.Arrow({
                    source: { id: source.id },
                    target: { id: target.id },
                    labels: [{ position: .5, attrs: { text: { text: label || '', 'font-weight': 'bold' } } }],
                    vertices: vertices || []
                });
                graph.addCell(cell);
                store.commit("setCurrentLink", cell);
                store.commit("setCurrentLinkLabel", label);
                doc[label]("ex:"+source.attributes.attrs.label.text, "ex:"+target.attributes.attrs.label.text);
                return cell;
            }
        }

        //function createElement(type,name,prefix,x,y) {
        //    let item;
        //    switch (type) {

        //        case 'entity':
        //            item = new joint.shapes.custom.Entity();
        //            item.attr('label/text', name);
        //            item.attr('prefix', prefix);
        //            let entity = doc.entity(prefix + ":" + name);
        //            break;

        //        case 'activity':
        //            item = new joint.shapes.custom.Activity();
        //            item.attr('label/text', name);
        //            item.attr('prefix', prefix);
        //            let activity = doc.activity(prefix + ":" + name);
        //            break;

        //        case 'agent':
        //            item = new joint.shapes.custom.Agent();
        //            item.attr('label/text', name);
        //            item.attr('prefix', prefix);
        //            let agent = doc.agent(prefix + ":" + name);
        //            break;
        //        default:
        //            throw new Error('Invalid item type');
        //    }
        //    item.resize(100, 40);

        //    if ((x != null) && (y != null)) {
        //        item.position(x, y);
        //    }
        //    item.addTo(graph);
        //    return item;
        //}

        function createElementNoPROV(type,x,y) {
            let item;
            switch (type) {
                case 'entity':
                    item = new joint.shapes.custom.Entity();
                    item.attr('label/text', type);
                    break;

                case 'activity':
                    item = new joint.shapes.custom.Activity();
                    item.attr('label/text', type);
                    break;

                case 'agent':
                    item = new joint.shapes.custom.Agent();
                    item.attr('label/text', type);
                    break;
                default:
                    throw new Error('Invalid item type');
            }
            item.resize(100, 40);

            if ((x != null) && (y != null)) {
                item.position(x, y);
            }
            item.addTo(graph);
            item.attr('body/magnet', 'passive');
            localStorage.setItem('graph', JSON.stringify(graph));
            return item;
        }

        //let activity = createElement('activity','writing','ex', 400, 500);
        //let entity = createElement('entity', 'story', 'ex', 400, 230);
        //let agent = createElement('agent', 'writer', 'ex', 100, 330);

        //var used = link(activity, entity, 'used', [{ x: 400, y: 400 }]);
        //var wasGeneratedBy = link(entity, activity, 'wasGeneratedBy', [{ x: 500, y: 400 }]);
        //var wasDerivedFrom = link(entity, entity, 'wasDerivedFrom', [{ x: 400, y: 150 }, { x: 500, y: 150 }]);
        //var wasAttributedTo = link(entity, agent, 'wasAttributedTo');
        //var wasAssociatedWith = link(activity, agent, 'wasAssociatedWith');

        window.onload = function () {
            document.getElementById("graph").addEventListener("click", function () {
                //console.log(event.clientX + "x" + event.clientY + "y");
                if(menuVisible)toggleMenu("hide"); //For context menu
                let activeTool = store.state.activeTool;
                let pointX = event.clientX-25;
                let pointY = event.clientY - 25;
                if (activeTool != "none") {
                    createElementNoPROV(activeTool, pointX, pointY); //Create element with no PROV information
                }
                store.commit('setActiveTool', 'none');
                event.stopPropagation();
            });
        }

        localStorage.setItem('graph', JSON.stringify(graph));
    
    </script>
</body>
</html>