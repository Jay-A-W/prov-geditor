<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/jointjs/2.1.0/joint.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="css/editor.css">
    <link rel="stylesheet" type="text/css" href="lib/jquery-ui-1.12.1/jquery-ui.css">
    <link rel="stylesheet" type="text/css" href="css/jquery-ui-timepicker-addon.css">
</head>
<body>
    <!-- content -->
    <div id="prov-editor">
        <sidebar></sidebar>
        <namespace-modal></namespace-modal>
        <element-modal></element-modal>
        <attr-modal></attr-modal>
        <export-modal></export-modal>
        <link-modal></link-modal>
        <div class="menu">
            <ul class="menu-options">
                <li class="menu-option option-wasGeneratedBy" onclick="addRelation('wasGeneratedBy')" hidden>wasGeneratedBy</li>
                <li class="menu-option option-wasDerivedFrom" onclick="addRelation('wasDerivedFrom')" hidden>wasDerivedFrom</li>
                <li class="menu-option option-wasAttributedTo" onclick="addRelation('wasAttributedTo')" hidden>wasAttributedTo</li>
                <li class="menu-option option-used" onclick="addRelation('used')" hidden>used</li>
                <li class="menu-option option-wasInformedBy" onclick="addRelation('wasInformedBy')" hidden>wasInformedBy</li>
                <li class="menu-option option-wasAssociatedWith" onclick="addRelation('wasAssociatedWith')" hidden>wasAssociatedWith</li>
                <li class="menu-option option-actedOnBehalfOf" onclick="addRelation('actedOnBehalfOf')" hidden>actedOnBehalfOf</li>

                <li class="menu-option option-wasInfluencedBy" onclick="addRelation('wasInfluencedBy')" hidden>wasInfluencedBy</li>
                <li class="menu-option option-hadPrimarySource" onclick="addRelation('hadPrimarySource')" hidden>hadPrimarySource</li>
                <li class="menu-option option-wasQuotedFrom" onclick="addRelation('wasQuotedFrom')" hidden>wasQuotedFrom</li>
                <li class="menu-option option-wasRevisionOf" onclick="addRelation('wasRevisionOf')" hidden>wasRevisionOf</li>
                <li class="menu-option option-wasInvalidatedBy" onclick="addRelation('wasInvalidatedBy')" hidden>wasInvalidatedBy</li>
                <li class="menu-option option-wasStartedBy" onclick="addRelation('wasStartedBy')" hidden>wasStartedBy</li>
                <li class="menu-option option-wasEndedBy" onclick="addRelation('wasEndedBy')" hidden>wasEndedBy</li>
            </ul>
        </div>
        <div id="graph"></div>
        <a href="#" onclick="show_doc_json(doc.scope);">exampleexample</a>
    </div>
    <!-- dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.8/dist/vue.js"></script>
    <script src="https://unpkg.com/vuex"></script>
    <script src="https://cdn.jsdelivr.net/npm/es6-promise@4/dist/es6-promise.auto.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.js"></script>
    <script src="lib/jquery-ui-1.12.1/jquery-ui.js"></script>
    <script src="lib/jquery-ui-timepicker-addon.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.10.1/lodash.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/backbone.js/1.3.3/backbone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jointjs/2.1.0/joint.js"></script>
    <script src="lib/customShapes/joint.shapes.custom.js"></script>
    <script type="text/javascript" src="lib/prov.js"></script>
    <script type="text/javascript" src="lib/api.js"></script>
    <script src="js/provFunc.js"></script>
    <script src="js/utlityFunctions.js"></script>
    <!-- Vue Declaration -->
    <script src="vue/sidebar.js"></script>
    <script src="vue/nameSpaceModal.js"></script>
    <script src="vue/elementModal.js"></script>
    <script src="vue/attrModal.js"></script>
    <script src="vue/linkModal.js"></script>
    <script src="vue/exportModal.js"></script>
    <script src="vue/index.js"></script>
    <!-- code -->
    <script type="text/javascript">

        //CURRENTLY LINKING WITH REVISION, QUOTATION, PRIMARYSOURCE DOES NOT WORK AS API IS MISSING FUNC!!!
        let doc = prov.document();
        store.commit("addPrefixToSet", 'xsd');
        store.commit("addPrefixToSet", 'prov');
        var def = doc.setDefaultNamespace("http://default.example.com/");
        store.commit("addPrefixToSet", 'default');
        var ex = doc.addNamespace("ex", "http://www.example.org/");
        store.commit("addPrefixToSet", 'ex');

        let json = {};
        let graph = new joint.dia.Graph;

        //localStorage.clear();
        var paper = new joint.dia.Paper({
            el: document.getElementById('graph'),
            model: graph,
            width: 2000,
            height: 2000,
            gridSize: 1,
            linkPinning: false,
            defaultLink: new joint.shapes.custom.fsa.Arrow({
            }),
            elementView: joint.dia.ElementView.extend({
                pointerdblclick: function (evt, x, y) {
                    store.commit("setCurrentElement", this);
                    $("#elementModal").show();
                },
                pointerclick: function (evt, x, y) {
                    if (store.state.activeTool == "attrTool") {
                        store.commit("setCurrentElement", this);
                        store.commit("setCurrentLink", "undefined");
                        $("#attrModal").show();
                        store.commit('setActiveTool', 'none');
                    }
                }
            }),
            linkView: joint.dia.LinkView.extend({
                pointerdblclick: function (evt, x, y) {
                    if (this.model.attributes.labels[0].attrs.text.text == "wasGeneratedBy") {
                        store.commit("setCurrentLink", this);
                        $("#linkModal").show();
                    }
                },
                pointerclick: function (evt, x, y) {
                    if (store.state.activeTool == "attrTool") {
                        store.commit("setCurrentElement", "undefined");
                        store.commit("setCurrentLink", this);
                        $("#attrModal").show();
                        store.commit('setActiveTool', 'none');
                    }
                }
            }),
        });

        if (localStorage.getItem('graph')) { //HAS TO BE DONE AFTER INSTANTIATION OF PAPER AS PAPER IS WHAT REACTS TO UPDATE GRAPH VISUALLY
            graph.fromJSON(JSON.parse(localStorage.getItem('graph')));
        }

        if (localStorage.getItem('doc')) {
            //let storeDoc = JSON.parse(localStorage.getItem('doc'));
            //let storeDoc = Object.assign(doc, JSON.parse(localStorage.getItem('doc')));
            //let storeScope = Object.assign(doc.scope, JSON.parse(localStorage.getItem('doc')).scope);
            //let storeNameSpace = Object.assign(doc.scope.namespaces, JSON.parse(localStorage.getItem('doc')).scope.namespaces);
            //let storeStatements = Object.assign(doc.scope.statements, JSON.parse(localStorage.getItem('doc')).scope.statements);
            doc.parent = JSON.parse(localStorage.getItem('doc')).parent;
            doc.scope.namespaces = JSON.parse(localStorage.getItem('doc')).scope.namespaces;
            //doc.scope.statements = JSON.parse(localStorage.getItem('doc')).scope.statements;
        }
        console.log(doc);
        const menu = document.querySelector(".menu");
        let menuVisible = false;

        const toggleMenu = command => {
            menu.style.display = command === "show" ? "block" : "none";
            menuVisible = !menuVisible;
        };

        const setPosition = ({ top, left }) => {
            menu.style.left = `${left}px`;
            menu.style.top = `${top}px`;
            toggleMenu('show');
        };

        function addRelation(label) {
            store.commit("setCurrentLinkLabel", label);
            doc[label]("ex:" + store.state.currentSource.attributes.attrs.label.text, "ex:" + store.state.currentTarget.attributes.attrs.label.text);
            localStorage.setItem('graph', JSON.stringify(graph));
            localStorage.setItem('doc', JSON.stringify(doc));
            for (let child of $(".menu-options").children()) {
                child.style.display = "none";
            }
            toggleMenu('hide');
        };

        function hideContextOptions(source, target) {
            let menuOptions = document.querySelector(".menu-options");

            let sourceType = source.attributes.type;
            let targetType = target.attributes.type;

            //let entity2Entity = ['wasDerivedFrom', 'wasInfluencedBy', 'hadPrimarySource', 'wasQuotedFrom', 'wasRevisionOf']; wasPrimary, Quoted and Revision has not been incorporate into the PROV api yet
            let entity2Entity = ['wasDerivedFrom', 'wasInfluencedBy'];
            let entity2Activity = ['wasGeneratedBy', 'wasInfluencedBy', 'wasInvalidatedBy'];
            let entity2Agent = ['wasAttributedTo', 'wasInfluencedBy'];
            let activity2Activity = ['wasInformedBy', 'wasInfluencedBy'];
            let activity2Entity = ['used', 'wasInfluencedBy', 'wasStartedBy', 'wasEndedBy'];
            let activity2Agent = ['wasAssociatedWith', 'wasInfluencedBy'];
            let agent2Agent = ['actedOnBehalfOf', 'wasInfluencedBy'];
            let agent2Entity = ['wasInfluencedBy'];
            let agent2Activity = ['wasInfluencedBy'];

            let validOptions;
            if (sourceType == 'custom.Entity') {
                switch (targetType) {
                    case 'custom.Entity':
                        validOptions = entity2Entity;
                        break;
                    case 'custom.Activity':
                        validOptions = entity2Activity;
                        break;
                    case 'custom.Agent':
                        validOptions = entity2Agent;
                        break;
                }
            } else if (sourceType == 'custom.Activity') {
                switch (targetType) {
                    case 'custom.Entity':
                        validOptions = activity2Entity;
                        break;
                    case 'custom.Activity':
                        validOptions = activity2Activity;
                        break;
                    case 'custom.Agent':
                        validOptions = activity2Agent;
                        break;
                }
            } else if (sourceType == 'custom.Agent') {
                switch (targetType) {
                    case 'custom.Entity':
                        validOptions = agent2Entity;
                        break;
                    case 'custom.Activity':
                        validOptions = agent2Activity;
                        break;
                    case 'custom.Agent':
                        validOptions = agent2Agent;
                        break;
                }
            }
            for (let option of validOptions) {
                $(".option-" + option).show();
            }
        };

        function getElementById(id) {
            for (let element of graph.getElements()) {
                if (element.id === id) {
                    return element;
                }
            }
        };

        //On connection
        graph.on('change:source change:target', function (link) {
            let source = link.get('source');
            let target = link.get('target');
            if (source.id && target.id) {
                // both ends of the link are connected.
                const origin = {
                    left: event.clientX,
                    top: event.clientY
                };
                setPosition(origin);
                let sourceElement = getElementById(source.id);
                let targetElement = getElementById(target.id);

                hideContextOptions(sourceElement, targetElement);
                store.commit("setCurrentSource", getElementById(source.id));
                store.commit("setCurrentTarget", getElementById(target.id));
                store.commit("setCurrentLink", link);
                //console.log(graph);
                return false;
            }
        })

        function deleteRelationInDoc(link) {
            let relType = link.attributes.attrs.relType;
            let qualifiedInfluence;
            let filtered;
            let source = getElementById(link.attributes.source.id);
            let target = getElementById(link.attributes.target.id);
            let sourceType = source.attributes.type.replace("custom.", "");
            let targetType = target.attributes.type.replace("custom.", "");
            switch (relType) {
                case "wasGeneratedBy":
                    qualifiedInfluence = "Generation";
                    filtered = filterOutLink(link, qualifiedInfluence);
                    doc.scope.statements = filtered;
                    break;
                case "wasDerivedFrom":
                    qualifiedInfluence = "Derivation";
                    filtered = doc.scope.statements.filter(function (link) {
                        if (link.constructor.name == qualifiedInfluence) {
                            if ((link.properties.hasOwnProperty('generatedEntity') && (link.properties.hasOwnProperty('usedEntity')))) {
                                if ((link['generatedEntity'].localPart == source.attributes.attrs.label.text) && (link['usedEntity'].localPart == target.attributes.attrs.label.text)) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    });
                    doc.scope.statements = filtered;
                    break;
                case "wasAttributedTo":
                    qualifiedInfluence = "Attribution";
                    filtered = filterOutLink(link, qualifiedInfluence);
                    doc.scope.statements = filtered;
                    break;
                case "used":
                    qualifiedInfluence = "Usage";
                    filtered = filterOutLink(link, qualifiedInfluence);
                    doc.scope.statements = filtered;
                    break;
                case "wasInformedBy":
                    qualifiedInfluence = "Communication";
                    filtered = doc.scope.statements.filter(function (link) {
                        if (link.constructor.name == qualifiedInfluence) {
                            if ((link.properties.hasOwnProperty('informed') && (link.properties.hasOwnProperty('informant')))) {
                                if ((link['informed'].localPart == source.attributes.attrs.label.text) && (link['informant'].localPart == target.attributes.attrs.label.text)) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    });
                    doc.scope.statements = filtered;
                    break;
                case "wasAssociatedWith":
                    qualifiedInfluence = "Association";
                    filtered = filterOutLink(link, qualifiedInfluence);
                    doc.scope.statements = filtered;
                    break;
                case "actedOnBehalfOf":
                    qualifiedInfluence = "Delegation";
                    filtered = doc.scope.statements.filter(function (link) {
                        if (link.constructor.name == qualifiedInfluence) {
                            if ((link.properties.hasOwnProperty('delegate') && (link.properties.hasOwnProperty('responsible')))) {
                                if ((link['delegate'].localPart == source.attributes.attrs.label.text) && (link['responsible'].localPart == target.attributes.attrs.label.text)) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    });
                    doc.scope.statements = filtered;
                    break;
                case "wasInfluencedBy":
                    qualifiedInfluence = "Influence";
                    filtered = doc.scope.statements.filter(function (link) {
                        if (link.constructor.name == qualifiedInfluence) {
                            if ((link.properties.hasOwnProperty('influencee') && (link.properties.hasOwnProperty('influencer')))) {
                                if ((link['influencee'].localPart == source.attributes.attrs.label.text) && (link['influencer'].localPart == target.attributes.attrs.label.text)) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    });
                    doc.scope.statements = filtered;
                    break;
                case "hadPrimarySource":
                    qualifiedInfluence = "PrimarySource";
                    filtered = filterOutLink(link, qualifiedInfluence);
                    doc.scope.statements = filtered;
                    break;
                case "wasQuotedFrom":
                    qualifiedInfluence = "Quotation";
                    filtered = filterOutLink(link, qualifiedInfluence);
                    doc.scope.statements = filtered;
                    break;
                case "wasRevisionOf":
                    qualifiedInfluence = "Revision";
                    filtered = filterOutLink(link, qualifiedInfluence);
                    doc.scope.statements = filtered;
                    break;
                case "wasInvalidatedBy":
                    qualifiedInfluence = "Invalidation";
                    filtered = filterOutLink(link, qualifiedInfluence);
                    doc.scope.statements = filtered;
                    break;
                case "wasStartedBy":
                    qualifiedInfluence = "Start";
                    filtered = doc.scope.statements.filter(function (link) {
                        if (link.constructor.name == qualifiedInfluence) {
                            if ((link.properties.hasOwnProperty(sourceType.toLowerCase()) && (link.properties.hasOwnProperty('trigger')))) {
                                if ((link[sourceType.toLowerCase()].localPart == source.attributes.attrs.label.text) && (link['trigger'].localPart == target.attributes.attrs.label.text)) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    });
                    doc.scope.statements = filtered;
                    break;
                case "wasEndedBy":
                    qualifiedInfluence = "End";
                    filtered = doc.scope.statements.filter(function (link) {
                        if (link.constructor.name == qualifiedInfluence) {
                            if ((link.properties.hasOwnProperty(sourceType.toLowerCase()) && (link.properties.hasOwnProperty('trigger')))) {
                                if ((link[sourceType.toLowerCase()].localPart == source.attributes.attrs.label.text) && (link['trigger'].localPart == target.attributes.attrs.label.text)) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    });
                    doc.scope.statements = filtered;
                    break;
            }
            //console.log(link);
            //console.log(doc.scope.statements);
        };

        //graph.on('remove', function(cell, cellView, evt) {
        //    if (cell.isLink()) {
        //    }
        //})

        paper.on('tool:remove', function (link, linkView, evt) {
            deleteRelationInDoc(link.model);
            link.model.remove();
            localStorage.setItem('graph', JSON.stringify(graph));
            localStorage.setItem('doc', JSON.stringify(doc));
        })

        paper.on('delete:button:pointerdown', function (elementView, evt) {
            evt.stopPropagation(); // stop any further actions with the element view (e.g. dragging)
            let model = elementView.model;
            let type = model.attributes.type.replace("custom.", "");
            let currentName = model.attributes.attrs.label.text;
            //let provElement = doc.scope.statements.filter(elementType => elementType.constructor.name == type).filter(element => element.identifier.localPart == currentName);
            let connectedLinks = graph.getConnectedLinks(model);
            for (let link of connectedLinks) {
                link.remove();
                deleteRelationInDoc(link);
            }
            let filtered = doc.scope.statements.filter(function (element) {
                if ((element.constructor.name == type) && (element.identifier.localPart == currentName)) {
                    return false;
                } else {
                    return true;
                }
            });
            doc.scope.statements = filtered;
            model.remove();
            localStorage.setItem('graph', JSON.stringify(graph));
            localStorage.setItem('doc', JSON.stringify(doc));
        });

        function link(source, target, label, vertices) {
            //doc.used("ex:" + source.id, "ex:" + target.id);
            //doc['used']("ex:" + source.id, "ex:" + target.id);
            let labelFunc = doc[label];

            //console.log(typeof labelFunc !== 'function');
            if (typeof labelFunc !== 'function') {
                throw new Error('invalid label type ' + label);
            } else {
                var cell = new joint.shapes.fsa.Arrow({
                    source: { id: source.id },
                    target: { id: target.id },
                    labels: [{ position: .5, attrs: { text: { text: label || '', 'font-weight': 'bold' } } }],
                    vertices: vertices || []
                });
                graph.addCell(cell);
                store.commit("setCurrentLink", cell);
                store.commit("setCurrentLinkLabel", label);
                doc[label]("ex:" + source.attributes.attrs.label.text, "ex:" + target.attributes.attrs.label.text);
                return cell;
            }
        }
        var ex = doc.addNamespace("ex", "http://www.example.org#");
        var dcterms = doc.addNamespace("dcterms", "http://purl.org/dc/terms/");
        var foaf = doc.addNamespace("foaf", "http://xmlns.com/foaf/0.1/");

        // Entities
        doc.entity("ex:article", ["dcterms:title", "Crime rises in cities"]);
        doc.entity("ex:dataSet1");
        doc.entity("ex:regionList");
        doc.entity("ex:compositionList");
        doc.entity("ex:chart1");

        // Activities
        doc.activity("ex:compile1");
        doc.activity("ex:compose1");
        doc.activity("ex:illustrate1");

        // Usage and Generation
        doc.used("ex:compose1", "ex:dataset1");
        doc.used("ex:compose1", "ex:regionList");
        doc.wasGeneratedBy("ex:composition1", "ex:compose1");
        doc.used("ex:illustrate1", "ex:composition1");
        doc.wasGeneratedBy("ex:chart1", "ex:illustrate1");

        // Agents and Responsibility
        doc.wasAssociatedWith("ex:compose1", "ex:derek");
        doc.wasAssociatedWith("ex:illustrate1", "ex:derek");
        doc.agent("ex:derek",
            ["prov:type", prov.ns.Person, "foaf:givenName", "Derek",
                "foaf:mbox", "<mailto:derek@example.org>"]);

        // Roles
        doc.agent("ex:chartgen",
            ["prov:type", prov.ns.Organization,
                "foaf:name", "Chart Generators Inc"]);
        doc.actedOnBehalfOf("ex:derek", "ex:chartgen");

        doc.wasAttributedTo("ex:chart1", "ex:derek");

        doc.used("ex:compose1", "ex:dataset1", ["prov:role", ex.qn("dataToCompose")]);
        doc.used("ex:compose1", "ex:regionList", ["prov:role", ex.qn("regionsToAggregateBy")]);
        doc.wasAssociatedWith("ex:compose1", "ex:derek", ["prov:role", ex.qn("analyst")]);
        doc.wasGeneratedBy("ex:composition1", "ex:compose1", ["prov:role", ex.qn("composedData")]);

        // Derivation and Revision
        doc.entity("ex:dataSet2");
        doc.wasDerivedFrom("ex:dataSet2", "ex:dataset1", ["prov:type", prov.ns.Revision]);
        doc.wasDerivedFrom("ex:chart2", "ex:dataSet2");
        doc.entity("ex:chart2");
        doc.wasDerivedFrom("ex:chart2", "ex:chart1", ["prov:type", prov.ns.Revision]);

        // Plans
        doc.activity("ex:correct1");
        doc.agent("ex:edith", ["prov:type", prov.ns.Person]);
        doc.entity("ex:instructions");
        doc.wasAssociatedWith("ex:correct1", "ex:edith", "ex:instructions");
        doc.wasGeneratedBy("ex:dataSet2", "ex:correct1");

        // Time
        doc.wasGeneratedBy("ex:chart1", "ex:compile1", "2012-03-02T10:30:00");
        doc.wasGeneratedBy("ex:chart2", "ex:compile2", "2012-04-01T15:21:00");
        doc.activity("ex:correct1", "2012-03-31T09:21:00", "2012-04-01T15:21:00");

        // Alternate Entities and Specialization
        doc.entity("ex:quoteInBlogEntry-20130326");
        doc.wasDerivedFrom("ex:quoteInBlogEntry-20130326", "ex:article", ["prov:type", prov.ns.Quotation]);

        doc.entity("ex:articleV1");
        doc.specializationOf("ex:articleV1", "ex:article");
        doc.specializationOf("ex:articleV2", "ex:article");
        doc.alternateOf("ex:articleV2", "ex:articleV1");
        //function createElement(type,name,prefix,x,y) {
        //    let item;
        //    switch (type) {

        //        case 'entity':
        //            item = new joint.shapes.custom.Entity();
        //            item.attr('label/text', name);
        //            item.attr('prefix', prefix);
        //            let entity = doc.entity(prefix + ":" + name);
        //            break;

        //        case 'activity':
        //            item = new joint.shapes.custom.Activity();
        //            item.attr('label/text', name);
        //            item.attr('prefix', prefix);
        //            let activity = doc.activity(prefix + ":" + name);
        //            break;

        //        case 'agent':
        //            item = new joint.shapes.custom.Agent();
        //            item.attr('label/text', name);
        //            item.attr('prefix', prefix);
        //            let agent = doc.agent(prefix + ":" + name);
        //            break;
        //        default:
        //            throw new Error('Invalid item type');
        //    }
        //    item.resize(100, 40);

        //    if ((x != null) && (y != null)) {
        //        item.position(x, y);
        //    }
        //    item.addTo(graph);
        //    return item;
        //}

        function createElementNoPROV(type, x, y) {
            let item;
            switch (type) {
                case 'entity':
                    item = new joint.shapes.custom.Entity();
                    item.attr('label/text', type);
                    break;

                case 'activity':
                    item = new joint.shapes.custom.Activity();
                    item.attr('label/text', type);
                    break;

                case 'agent':
                    item = new joint.shapes.custom.Agent();
                    item.attr('label/text', type);
                    break;
                default:
                    throw new Error('Invalid item type');
            }
            item.resize(100, 40);

            if ((x != null) && (y != null)) {
                item.position(x, y);
            }
            item.addTo(graph);
            item.attr('body/magnet', 'passive');
            localStorage.setItem('graph', JSON.stringify(graph));
            localStorage.setItem('doc', JSON.stringify(doc));
            return item;
        }

        //let activity = createElement('activity','writing','ex', 400, 500);
        //let entity = createElement('entity', 'story', 'ex', 400, 230);
        //let agent = createElement('agent', 'writer', 'ex', 100, 330);

        //var used = link(activity, entity, 'used', [{ x: 400, y: 400 }]);
        //var wasGeneratedBy = link(entity, activity, 'wasGeneratedBy', [{ x: 500, y: 400 }]);
        //var wasDerivedFrom = link(entity, entity, 'wasDerivedFrom', [{ x: 400, y: 150 }, { x: 500, y: 150 }]);
        //var wasAttributedTo = link(entity, agent, 'wasAttributedTo');
        //var wasAssociatedWith = link(activity, agent, 'wasAssociatedWith');

        window.onload = function () {
            document.getElementById("graph").addEventListener("click", function () {
                //console.log(event.clientX + "x" + event.clientY + "y");
                if (menuVisible) toggleMenu("hide"); //For context menu
                let activeTool = store.state.activeTool;
                let pointX = event.clientX - 25;
                let pointY = event.clientY - 25;
                if ((activeTool == "entity")|| (activeTool == "activity") || (activeTool == "agent")) {
                    createElementNoPROV(activeTool, pointX, pointY); //Create element with no PROV information
                    store.commit('setActiveTool', 'none');
                }
                event.stopPropagation();
            });
        }
        localStorage.setItem('graph', JSON.stringify(graph));
        localStorage.setItem('doc', JSON.stringify(doc));

    </script>
</body>
</html>